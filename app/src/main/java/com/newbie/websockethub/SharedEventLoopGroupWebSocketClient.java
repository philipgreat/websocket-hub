/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.newbie.websockethub;

import com.newbie.indexprice.core.PriceProvider;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.compression.JdkZlibDecoder;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;

import javax.net.ssl.SSLException;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.zip.GZIPInputStream;

public class SharedEventLoopGroupWebSocketClient {

    private static final EventLoopGroup group = new NioEventLoopGroup();

    public static void main(String[] args) throws Exception {
        URI uri1 = new URI("wss://api.huobi.pro:443/ws");
        //URI uri2 = new URI("ws://iotlog.doublechaintech.com:80/message-center/public");

        // 使用相同的EventLoopGroup连接到不同的服务器
        new SharedEventLoopGroupWebSocketClient().connectToWebSocket(uri1, group);


        // 添加一个钩子以在JVM关闭时优雅地关闭EventLoopGroup
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            group.shutdownGracefully();
        }));
    }

    private  void connectToWebSocket(URI uri, EventLoopGroup sharedGroup) throws InterruptedException {
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(sharedGroup)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<Channel>() {
                    @Override
                    protected void initChannel(Channel ch) throws Exception {
                        ChannelPipeline pipeline = ch.pipeline();
                        applySSLContextIfNeeded(uri,pipeline,ch);

                        pipeline.addLast(new HttpClientCodec(),
                                new HttpObjectAggregator(8192),
                                new WebSocketClientProtocolHandler(uri, WebSocketVersion.V13, null, false, null, 65536),
                                WebSocketClientCompressionHandler.INSTANCE,
                        new SimpleChannelInboundHandler<WebSocketFrame>() {
                            @Override
                            public void channelActive(ChannelHandlerContext ctx) throws Exception {
                                super.channelActive(ctx);

                                ctx.writeAndFlush(new TextWebSocketFrame("{\"sub\":\"market.btcusdt.trade.detail\",\"id\":\"crypto-ws-client\"}"));

                            }

                            @Override
                                    protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
                                        if(frame instanceof TextWebSocketFrame){
                                            System.out.println("Received message from " + uri + ": " + ((TextWebSocketFrame)frame).text());
                                            return;
                                        }
                                        System.out.println("Received binary message from " + uri + ": "+frame.getClass());
                                        if(frame instanceof BinaryWebSocketFrame){
                                            BinaryWebSocketFrame binaryFrame = (BinaryWebSocketFrame) frame;
                                            ByteBuf content = binaryFrame.content();
                                            byte[] data = new byte[content.readableBytes()];
                                            content.readBytes(data);//ctx
                                            String value=new String(decompressGzip(data));
                                            if(value.startsWith("{\"ping")){
                                                ctx.writeAndFlush(new TextWebSocketFrame(value.replace('i','o')));
                                            }

                                            System.out.println("value "+value);
                                        }

                                    }
                                });
                    }
                });

        Channel channel = bootstrap.connect(uri.getHost(), uri.getPort()).sync().channel();
        //channel.writeAndFlush(new TextWebSocketFrame("{\"sub\":\"market.btcusdt.trade.detail\",\"id\":\"crypto-ws-client\"}"));
        //channel.writeAndFlush(new TextWebSocketFrame("{\"sub\":\"market.ethusdt.trade.detail\",\"id\":\"crypto-ws-client\"}"));

        // 不要在这里关闭Future，因为我们想要保持连接开放
        //channel.closeFuture().await();
    }
    public static byte[] decompressGzip(ByteBuf compressed) throws Exception {
        // Ensure the buffer is a direct buffer for decompression
        ByteBuf decompressed = Unpooled.directBuffer();
        JdkZlibDecoder zlibDecoder = new JdkZlibDecoder(true); // true for GZIP

        try {
            // Offer the compressed data to the decoder
            zlibDecoder.channelRead(null, compressed);

            // Reading the decompressed data
            while (zlibDecoder.isClosed() == false) {
                ByteBuf part = Unpooled.directBuffer();
                zlibDecoder.channelRead(null, part);
                decompressed.writeBytes(part);
                part.release();
            }

            // Convert ByteBuf to byte[]
            byte[] result = new byte[decompressed.readableBytes()];
            decompressed.readBytes(result);
            return result;
        } finally {
            // Release resources
            decompressed.release();
            zlibDecoder.handlerRemoved(null);
        }
    }

    public static byte[] decompressGzip(byte[] compressedData) throws IOException {
        try (ByteArrayInputStream bin = new ByteArrayInputStream(compressedData);
             GZIPInputStream gzipInputStream = new GZIPInputStream(bin);
             ByteArrayOutputStream bout = new ByteArrayOutputStream()) {

            byte[] buffer = new byte[1024];
            int len;
            while ((len = gzipInputStream.read(buffer)) > 0) {
                bout.write(buffer, 0, len);
            }

            return bout.toByteArray();
        }
    }
    private void applySSLContextIfNeeded(URI uri, ChannelPipeline pipeline, Channel ch) throws SSLException, URISyntaxException {

        if(uri.getScheme().startsWith("wss")){
            SslContext sslCtx= SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();

            pipeline.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), uri.getPort()));

        }

    }
}